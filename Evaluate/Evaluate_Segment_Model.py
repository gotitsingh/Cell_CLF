import torch
from torch import nn
from torch import optim
from torch.optim import lr_scheduler
import os
from ops.os_operation import mkdir
import datetime
import time
from Model.Resnet import resnet20
from Training.utils import Logger,save_checkpoint
from Data_Processing.Calculate_Mean_STD import Calculate_Mean_STD
from Training.train_epoch import train_epoch
from Training.Val_epoch import val_epoch
import numpy as np
from Evaluate.CV2Segment_Predict_Img import CV2Segment_Image
from PIL import Image
from Segment.CV2_overall_predict import CV2_overall_predict
from Data_Processing.Generate_Segemented_Image import Extract_Coord_list
import pandas as pd
from Evaluate.Predict_img_Coord import Predict_img_Coord
def Evaluate_Segment_Model(params,testing_path,model_path):
    model = resnet20(num_class=params['class'])

    model = model.cuda()
    model = nn.DataParallel(model, device_ids=None)
    # reload the model
    model_state_dict = torch.load(model_path)
    if 'ema_state_dict' in model_state_dict.keys():
        print("Load EMA model")
        model.load_state_dict(model_state_dict['ema_state_dict'])
    else:
        print("Load common model")
        model.load_state_dict(model_state_dict['state_dict'])
    mean_value = (0.59187051, 0.53104666, 0.56797799)
    std_value = (0.19646512, 0.23195337, 0.20233912)
    Test_path_List=[]
    with open(testing_path,'r') as file:
        line=file.readline()
        while line:
            line=line.strip()
            Test_path_List.append(line)
            line=file.readline()
    study_path=os.path.join(os.getcwd(),"Eval_Seg_Prediction")
    mkdir(study_path)
    height = params['height']
    width = params['width']
    PRecords=[]
    NRecords=[]
    Name_List=[]
    for tmp_test_path in Test_path_List:
        tmp_name_split=os.path.split(tmp_test_path)
        tmp_name=tmp_name_split[1]
        tmp_study_path=os.path.join(study_path,tmp_name)
        mkdir(tmp_study_path)
        tmp_positive_path=tmp_test_path[:-4]+" posi.xls"
        tmp_negative_path=tmp_test_path[:-4]+" nega.xls"
        if not os.path.exists(tmp_positive_path) and not os.path.exists(tmp_negative_path):
            tmp_positive_path = tmp_test_path[:-4] + " osteoclasts.xls"
            tmp_negative_path = tmp_test_path[:-4] + " non-osteoclasts.xls"
        if not os.path.exists(tmp_positive_path) and not os.path.exists(tmp_negative_path):
            tmp_positive_path=tmp_name_split[0]+"/Results "+tmp_name[:-4]+" posi.xls"
            tmp_negative_path=tmp_name_split[0]+"/Results "+tmp_name[:-4]+" nega.xls"
        if not os.path.exists(tmp_positive_path) and not os.path.exists(tmp_negative_path):
            tmp_positive_path = tmp_test_path[:-4] + " new posi.xls"
            tmp_negative_path = tmp_test_path[:-4] + " new nega.xls"
        #first do the segmentation and prediction
        tmp_predict_path=os.path.join(tmp_study_path,"Segment_Prediction")
        mkdir(tmp_predict_path)

        Markers = CV2Segment_Image(tmp_test_path, tmp_predict_path, params)
        im = Image.open(tmp_test_path)
        imarray = np.array(im)
        CV2_overall_predict(model, height, width, Markers, imarray, mean_value, std_value,tmp_predict_path, params,tmp_name[:-4])
        predict_result_path=os.path.join(tmp_predict_path,"Predict_"+str(tmp_name[:-4])+".txt")#generated by previous function
        Coord_Dict,Search_key_dict=Build_Coord_Dict(Markers)
        Name_List.append(tmp_name)
        if os.path.exists(tmp_positive_path):
            Record_Info_P=Analyze_Extracted_Prediction(imarray,predict_result_path,tmp_positive_path,"Positive",tmp_study_path,Coord_Dict,Markers,width,height,Search_key_dict)
            PRecords.append(Record_Info_P)
            print("Finished Positive for %s, with accuracy %.4f recall rate: %.4f"%(tmp_name,Record_Info_P[-2],Record_Info_P[-1]))
        if os.path.exists(tmp_negative_path):
            Record_Info_N=Analyze_Extracted_Prediction(imarray,predict_result_path,tmp_negative_path,"Negative",tmp_study_path,Coord_Dict,Markers,width,height,Search_key_dict)
            print("Finished Negative for %s, with accuracy %.4f recall rate: %.4f" % (
            tmp_name, Record_Info_N[-2], Record_Info_N[-1]))
        center_predict_path=os.path.join(tmp_study_path,"Center_Predict")
        mkdir(center_predict_path)
        if os.path.exists(tmp_positive_path):
            Marked_Coord1 = Extract_Coord_list(tmp_positive_path)
        else:
            Marked_Coord1 =[]
        if os.path.exists(tmp_negative_path):
            Marked_Coord2 = Extract_Coord_list(tmp_negative_path)
        else:
            Marked_Coord2=[]
        if len(Marked_Coord1+len(Marked_Coord2))!=0:
            Predict_img_Coord(model, height, width, Marked_Coord1+Marked_Coord2, imarray, mean_value, std_value, center_predict_path, params)
            NRecords.append(Record_Info_N)
        else:
            print("We do not have label for input %s"%tmp_test_path)
    #build table
    PRecords=np.array(PRecords)
    NRecords=np.array(NRecords)
    tmp_table_path=os.path.join(study_path,"Overall_Report.xls")
    data_df = pd.DataFrame(PRecords)
    data_df.index = Name_List
    data_df.columns = ['#Correct',"#Find","#Total","Accuracy","Recall"]
    writer = pd.ExcelWriter(tmp_table_path)
    data_df.to_excel(writer, 'Positive', float_format='%.4f')
    data_df = pd.DataFrame(NRecords)
    data_df.index = Name_List
    data_df.columns = ['#Correct', "#Find", "#Total", "Accuracy", "Recall"]
    data_df.to_excel(writer, 'Negative', float_format='%.4f')
    writer.save()
def Draw_OriginCoord_Figure(tmp_coord_figure_path, coord_list, imarray):
    img = Image.fromarray(imarray.astype(np.uint8))
    draw = ImageDraw.Draw(img)
    for k in range(len(coord_list)):
        tmp_coord = coord_list[k]
        draw.text((tmp_coord[0], tmp_coord[1]), "C", fill=(255, 255, 255))
    img.save(tmp_coord_figure_path)
def Analyze_Extracted_Prediction(imarray,predict_result_path,tmp_coord_path,tmp_save_label,tmp_study_path,Coord_Dict,Markers,width,height,Search_key_dict):
    tmp_study_path=os.path.join(tmp_study_path,tmp_save_label+"_Analysis")
    mkdir(tmp_study_path)
    if tmp_save_label=="Positive":
        correct_label=1
    else:
        correct_label=0
    Marked_Coord=Extract_Coord_list(tmp_coord_path)#based on image coord
    #first make a plot based on this
    tmp_coord_figure_path = os.path.join(tmp_study_path, "Origin_Coord_Info"+str(correct_label)+".png")
    Draw_OriginCoord_Figure(tmp_coord_figure_path, Marked_Coord, imarray)
    Predicted_Result,Predicted_Prob=Extract_Info_From_Pred(predict_result_path)#coord based on image
    checked_width=0.6*width
    checked_height=0.6*height
    count_find=0
    count_correct=0
    Coord_List=[]
    Real_Coord_List=[]
    Label_List=[]
    print("Segmented Markers shape",Markers.shape)#markers shape agrees with iamge array
    Marked_Coord=np.array(Marked_Coord)#shape agreed well with image
    max_x=np.max(Marked_Coord[:,0])
    max_y=np.max(Marked_Coord[:,1])
    print("Marked coord shape:(%d,%d) with size %d"%(max_x,max_y,len(Marked_Coord)))
    for tmp_check_coord in Marked_Coord:
        base_x=tmp_check_coord[1]#because x,y is different form the imarray
        base_y=tmp_check_coord[0]#here based on image
        #markers with same shape as imarray
        mark_label = Markers[base_x, base_y]#markers based on image array shape
        if mark_label > 1:
            # it's in the selected area of some labeled part
            key = Search_key_dict[int(mark_label)]
            matched_id=Coord_Dict[key]
            tmp_split = key.split(",")
            locate_x = int(tmp_split[1])#real pos in image
            locate_y = int(tmp_split[0])
            check_key = ""
            check_key += str(locate_x) + ","
            check_key += str(locate_y) + ","
            pred_label = Predicted_Result[check_key]
            pred_prob = Predicted_Prob[check_key]

            global_pred_path = os.path.join(tmp_study_path, "Finding_global%d_matchid%d.png" % (count_find, matched_id))
            Draw_Located_Image(imarray, locate_x, locate_y, Markers, matched_id, global_pred_path, pred_label,
                               pred_prob)
            local_pred_path = os.path.join(tmp_study_path, "Finding_local%d_matchid%d.png" % (count_find, matched_id))
            Save_Local_Segmented_Image(imarray, local_pred_path, height, width, [locate_x, locate_y], correct_label,
                                       pred_prob, pred_label)
            # draw local
            if pred_label == correct_label:
                count_correct += 1
            count_find += 1
            Coord_List.append([locate_x, locate_y])#based on image
            Real_Coord_List.append([base_x, base_y])#based on image array
            Label_List.append(pred_label)
            continue
        matched_id=-1
        use_key=-1
        locate_x=0
        locate_y=0
        min_distance=999999999999999
        for key in Predicted_Result:
            tmp_split=key.split(",")#real pos on image
            tmp_x=int(tmp_split[1])
            tmp_y=int(tmp_split[0])#now change to based on imarray
            dist_x=abs(tmp_x-base_x)
            dist_y=abs(tmp_y-base_y)
            if dist_x<checked_width and dist_y<checked_height:
                current_distance=(tmp_x-base_x)**2+(tmp_y-base_y)**2#L2 distance
                if current_distance<min_distance:
                    min_distance=current_distance
                    check_key=""
                    check_key+=str(tmp_x)+","
                    check_key += str(tmp_y) + ","
                    matched_id=Coord_Dict[check_key]
                    locate_x=tmp_y
                    locate_y=tmp_x
                    use_key=key
        if matched_id!=-1:
            #first save the image, locate the area
            pred_label=Predicted_Result[use_key]
            pred_prob=Predicted_Prob[use_key]
            global_pred_path=os.path.join(tmp_study_path,"Nearest_Finding_global%d_matchid%d.png"%(count_find,matched_id))
            Draw_Located_Image(imarray, locate_x, locate_y, Markers, matched_id, global_pred_path, pred_label, pred_prob)
            local_pred_path=os.path.join(tmp_study_path,"Nearest_Finding_local%d_matchid%d.png"%(count_find,matched_id))
            Save_Local_Segmented_Image(imarray, local_pred_path, height, width, [locate_x,locate_y], correct_label, pred_prob,pred_label)
            #draw local
            if pred_label==correct_label:
                count_correct+=1
            count_find += 1
            Coord_List.append([locate_x,locate_y])
            Real_Coord_List.append([base_x,base_y])
            Label_List.append(pred_label)
        else:
            #adding markers check
            Real_Coord_List.append([base_x,base_y])
    #using a real coord to predict
    print("for %s eval"%tmp_save_label,Label_List)
    #draw a picture to compare the predictions
    figure_path=os.path.join(tmp_study_path,"Compare_Pred.png")
    Draw_Compare_Image(imarray,Real_Coord_List,Coord_List,Label_List,figure_path)
    print("Checking finish, %d/%d/%d"%(count_correct,count_find,len(Marked_Coord)))
    if count_find!=0:
        return [count_correct,count_find,len(Marked_Coord),count_correct/count_find,count_find/len(Marked_Coord)]
    else:
        return [count_correct, count_find, len(Marked_Coord),0, 0/ len(Marked_Coord)]
from PIL import Image,ImageFont,ImageDraw
def Draw_Located_Image(imarray,locate_x,locate_y,Markers,tmp_label,tmp_path,label,pred_prob):
    remained_imarray=np.zeros(imarray.shape)
    for i in range(imarray.shape[0]):
        for j in range(imarray.shape[1]):
            if Markers[i,j]==tmp_label:#markers shape agree with the imarray
                remained_imarray[i,j,:]=imarray[i,j,:]
    img = Image.fromarray(remained_imarray.astype(np.uint8))
    draw = ImageDraw.Draw(img)
    draw.text((locate_x, locate_y), "Label:%d, Probability:%.4f"%(label,pred_prob), fill=(255, 255, 255))
    img.save(tmp_path)
def Draw_Compare_Image(imarray,Real_Coord_List,Coord_List,Label_List,figure_path):
    img = Image.fromarray(imarray.astype(np.uint8))
    draw = ImageDraw.Draw(img)
    for k in range(len(Real_Coord_List)):
        tmp_coord = Real_Coord_List[k]
        draw.text((tmp_coord[1], tmp_coord[0]), "C", fill=(255, 255, 255))
    for k in range(len(Coord_List)):
        tmp_coord = Coord_List[k]
        pred_label=Label_List[k]
        draw.text((tmp_coord[0], tmp_coord[1]), "P"+str(pred_label), fill=(255, 255, 255))
    img.save(figure_path)
def Save_Local_Segmented_Image(imarray,save_path,height,width,tmp_coord,label,pred_prob,pred_label):
    overall_width=imarray.shape[0]
    overall_height=imarray.shape[1]

    if True:
        tmp_x=tmp_coord[1]
        tmp_y=tmp_coord[0]
        assert tmp_x<overall_width and tmp_y<overall_height
        ##in this label x is y, y is x

        #print(tmp_x,tmp_y)
        tmp_left=tmp_x-int(width/2)
        tmp_bottom=tmp_y-int(height/2)
        #print(tmp_left,tmp_bottom)
        tmp_array=np.zeros([width,height,3])
        right_end=tmp_left+width if tmp_left+width<overall_width else overall_width
        upper_end=tmp_bottom+height if tmp_bottom+height<overall_height else overall_height
        #print(right_end,upper_end)
        left_start=0 if tmp_left<0 else tmp_left
        bottom_start=0 if tmp_bottom<0 else tmp_bottom
        tmp_width=int(right_end-left_start)
        tmp_height=int(upper_end-bottom_start)
        #print(tmp_width,tmp_height)
        tmp_left_start=int((width-tmp_width)/2)
        tmp_bottom_start=int((height-tmp_height)/2)
        tmp_array[tmp_left_start:tmp_left_start+tmp_width,tmp_bottom_start:tmp_height+tmp_bottom_start,:]=\
            imarray[left_start:right_end,bottom_start:upper_end,:]#set to center for new image
        img=Image.fromarray(tmp_array.astype(np.uint8))
        #tmp_img_path=os.path.join(save_path,str(label)+"_x_"+str(tmp_y)+"y_"+str(tmp_x)+'.png')
        #draw = ImageDraw.Draw(img)
        #draw.text((0, 0), "Predicted Label:%d, Probability:%.4f" % (pred_label, pred_prob), fill=(255, 255, 255))
        #draw.text((5, 0), "Coord info:x: %d, y:%d" % (tmp_y,tmp_x), fill=(255, 255, 255))
        img.save(save_path)



def Extract_Info_From_Pred(predict_result_path):
    Predicted_Result={}
    Predicted_Prob={}
    count_positive=0
    count_negative=0
    with open(predict_result_path,'r') as file:
        line=file.readline()
        line=file.readline()
        while line:
            line=line.strip()
            split_Result=line.split()
            key=""
            key+=str(int(split_Result[0]))+","
            key += str(int(split_Result[1])) + ","
            pred_label=int(split_Result[2])
            pred_prob=float(split_Result[3])
            Predicted_Result[key]=pred_label
            if pred_label==1:
                count_positive+=1
            else:
                count_negative+=1
            Predicted_Prob[key]=pred_prob
            line=file.readline()
    #add analysis about percentage
    print("For prediction results, we have %d positive predictions "
          "and %d negative predictions, positive rate %.4f"%(count_positive,count_negative,count_positive/(count_negative+count_positive)))
    return Predicted_Result,Predicted_Prob

def Build_Coord_Dict(Overall_Segment_Array):
    Coord_Dict={}
    Search_Key_Dict={}
    label_list=np.unique(Overall_Segment_Array)
    print("In total, we have %d segmented areas waiting to be predicted"%(len(label_list)-3))
    for tmp_label in label_list:
        if tmp_label<=1:
            continue
        Coord_List=np.argwhere(Overall_Segment_Array==tmp_label)
        X_list=[]
        Y_list=[]
        for tmp_coord in Coord_List:
            X_list.append(tmp_coord[0])
            Y_list.append(tmp_coord[1])
        X_list=np.array(X_list)
        Y_list=np.array(Y_list)
        if len(X_list)==0:
            continue
        X_mean=int(np.mean(X_list))
        Y_mean=int(np.mean(Y_list))
        key=""
        key+=str(X_mean)+','
        key+=str(Y_mean)+','
        Coord_Dict[key]=int(tmp_label)
        Search_Key_Dict[int(tmp_label)]=key
    return Coord_Dict,Search_Key_Dict#return array based coord

